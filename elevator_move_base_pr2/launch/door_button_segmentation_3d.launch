<launch>

  <arg name="NS" default="door_button"/>
  <arg name="MANAGER" default="door_button_segmentation_manager"/>
  <arg name="INPUT_IMAGE" default="/kinect_head_c2/rgb/image_rect_color"/>
  <arg name="INPUT_CLOUD" default="/kinect_head_c2/depth_registered/points"/>
  <arg name="FIXED_FRAME" default="/head_mount_kinect_rgb_optical_frame"/>
  <arg name="MODEL_FILE" default="$(find elevator_move_base_pr2)/trained_model/fcn8s_atonce_door_button_model.npz"/>
  <arg name="GPU" default="-1"/>

  <group ns="$(arg NS)">

    <node name="$(arg MANAGER)"
          pkg="nodelet" type="nodelet"
          args="manager"
          output="screen"
          respawn="true">
    </node>

    <!-- Segment door button 2-dimentionally by FCN -->
    <node name="fcn_object_segmentation"
          pkg="jsk_perception" type="fcn_object_segmentation.py"
          output="screen"
          respawn="true">
      <remap from="~input" to="$(arg INPUT_IMAGE)"/>  <!-- rgb timestamp -->
      <rosparam subst_value="true">
        use_mask: false
        gpu: $(arg GPU)
        model_name: fcn8s_atonce
        model_file: $(arg MODEL_FILE)
        target_names:
        - _background_
        - button
        bg_label: 0
        proba_threshold: 0.0
      </rosparam>
    </node>

    <!-- Pipeline to get 3-dimentional bounding box of door button -->
    <!-- label -> mask -> indices -> cloud -> cluster indices -> bboxes -->
    <node name="label_to_mask"
          pkg="nodelet" type="nodelet"
          args="load jsk_perception/LabelToMaskImage $(arg MANAGER)"
          output="screen"
          respawn="true">
      <remap from="~input" to="fcn_object_segmentation/output"/>  <!-- rgb timestamp -->
      <rosparam>
        label_value: 1
      </rosparam>
    </node>

    <node name="mask_to_point_indices"
          pkg="nodelet" type="nodelet"
          args="load jsk_pcl_utils/MaskImageToPointIndices $(arg MANAGER)"
          output="screen"
          respawn="true">
      <remap from="~input" to="label_to_mask/output"/>  <!-- rgb timestamp -->
    </node>

    <node name="extract_indices"
          pkg="nodelet" type="nodelet"
          args="load jsk_pcl/ExtractIndices $(arg MANAGER)"
          output="screen"
          respawn="true">
      <remap from="~input" to="$(arg INPUT_CLOUD)"/>  <!-- depth timestamp -->
      <remap from="~indices" to="mask_to_point_indices/output"/>  <!-- rgb timestamp -->
      <rosparam>
        approximate_sync: true
        queue_size: 1000
        keep_organized: true
      </rosparam>
    </node>

    <node name="euclidean_clustering"
          pkg="nodelet" type="nodelet"
          args="load jsk_pcl/EuclideanClustering $(arg MANAGER)"
          output="screen"
          respawn="true">
      <remap from="~input" to="extract_indices/output"/>  <!-- depth timestamp -->
      <rosparam>
        min_size: 100
        max_size: 10000
        tolerance: 0.05
      </rosparam>
    </node>

    <node name="cluster_indices_decomposer"
          pkg="nodelet" type="nodelet"
          args="load jsk_pcl/ClusterPointIndicesDecomposer $(arg MANAGER)"
          output="screen"
          respawn="true">
      <remap from="~input" to="extract_indices/output"/>  <!-- depth timestamp -->
      <remap from="~target" to="euclidean_clustering/output"/>  <!-- depth timestamp -->
      <rosparam subst_value="true">
        approximate_sync: false
        queue_size: 1000
        sort_by: -cloud_size
        align_boxes: true
        align_boxes_with_plane: false
        use_pca: true
        target_frame_id: $(arg FIXED_FRAME)
      </rosparam>
    </node>

    <!-- Visualization -->
    <node name="label_image_decomposer"
          pkg="jsk_perception" type="label_image_decomposer.py"
          output="screen"
          respawn="true">
      <remap from="~input" to="$(arg INPUT_IMAGE)"/>  <!-- rgb timestamp -->
      <remap from="~input/label" to="fcn_object_segmentation/output"/>  <!-- rgb timestamp -->
      <rosparam>
        label_names:
        - _background_
        - button
        bg_label: 0
        approximate_sync: false
        queue_size: 1000
      </rosparam>
    </node>

  </group>

</launch>
