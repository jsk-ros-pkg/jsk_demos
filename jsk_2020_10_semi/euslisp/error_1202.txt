24.E1-irteusgl$ (send *ri* :angle-vector (send *fetch* :angle-vector) 5000 :use-torso nil)
[ WARN] [1606921302.638850734]: continuous joint (upperarm_roll_joint) moves 360.0 degree, commanded joint differs from original trajectory to avoid unintentional 360 rotation
Call Stack (max depth: 20):
  0: at (apply #'send-message self (class . super) :angle-vector-sequence args)
  1: at (apply #'send-message self (class . super) :angle-vector-sequence args)
  2: at (apply #'send-message self (class . super) :angle-vector-sequence args)
  3: at (send-super* :angle-vector-sequence args)
  4: at (apply #'send self :angle-vector-sequence-raw avs (make-list div :initial-element (/ tm div)) args)
  5: at (apply #'send self :angle-vector-sequence-raw avs (make-list div :initial-element (/ tm div)) args)
  6: at (send* self :angle-vector-sequence-raw avs (make-list div :initial-element (/ tm div)) args)
  7: at (let* (avs (minjerk (instance minjerk-interpolator :init)) (scale-av (send self :sub-angle-vector av prev-av)) dist div) (setq dist (abs (find-extream (coerce diff-av cons) #'abs #'>=))) (setq div (round (/ dist 120.0))) (send minjerk :reset :position-list (list prev-av (v+ prev-av scale-av)) :time-list (list tm)) (send minjerk :start-interpolation) (send minjerk :pass-time (/ tm div)) (dotimes (i div) (setq avs (append avs (list (send minjerk :pass-time (/ tm div)))))) (send* self :angle-vector-sequence-raw avs (make-list div :initial-element (/ tm div)) args) (return-from :angle-vector-raw (car (last avs))))
  8: at (progn (let* (avs (minjerk (instance minjerk-interpolator :init)) (scale-av (send self :sub-angle-vector av prev-av)) dist div) (setq dist (abs (find-extream (coerce diff-av cons) #'abs #'>=))) (setq div (round (/ dist 120.0))) (send minjerk :reset :position-list (list prev-av (v+ prev-av scale-av)) :time-list (list tm)) (send minjerk :start-interpolation) (send minjerk :pass-time (/ tm div)) (dotimes (i div) (setq avs (append avs (list (send minjerk :pass-time (/ tm div)))))) (send* self :angle-vector-sequence-raw avs (make-list div :initial-element (/ tm div)) args) (return-from :angle-vector-raw (car (last avs)))))
  9: at (if (send self :check-continuous-joint-move-over-180 diff-av) (progn (let* (avs (minjerk (instance minjerk-interpolator :init)) (scale-av (send self :sub-angle-vector av prev-av)) dist div) (setq dist (abs (find-extream (coerce diff-av cons) #'abs #'>=))) (setq div (round (/ dist 120.0))) (send minjerk :reset :position-list (list prev-av (v+ prev-av scale-av)) :time-list (list tm)) (send minjerk :start-interpolation) (send minjerk :pass-time (/ tm div)) (dotimes (i div) (setq avs (append avs (list (send minjerk :pass-time (/ tm div)))))) (send* self :angle-vector-sequence-raw avs (make-list div :initial-element (/ tm div)) args) (return-from :angle-vector-raw (car (last avs))))))
  10: at (when (send self :check-continuous-joint-move-over-180 diff-av) (let* (avs (minjerk (instance minjerk-interpolator :init)) (scale-av (send self :sub-angle-vector av prev-av)) dist div) (setq dist (abs (find-extream (coerce diff-av cons) #'abs #'>=))) (setq div (round (/ dist 120.0))) (send minjerk :reset :position-list (list prev-av (v+ prev-av scale-av)) :time-list (list tm)) (send minjerk :start-interpolation) (send minjerk :pass-time (/ tm div)) (dotimes (i div) (setq avs (append avs (list (send minjerk :pass-time (/ tm div)))))) (send* self :angle-vector-sequence-raw avs (make-list div :initial-element (/ tm div)) args) (return-from :angle-vector-raw (car (last avs)))))
  11: at (let* ((prev-av (send self :state :potentio-vector :wait-until-update t)) (diff-av (v- av prev-av))) (when (send self :check-continuous-joint-move-over-180 diff-av) (let* (avs (minjerk (instance minjerk-interpolator :init)) (scale-av (send self :sub-angle-vector av prev-av)) dist div) (setq dist (abs (find-extream (coerce diff-av cons) #'abs #'>=))) (setq div (round (/ dist 120.0))) (send minjerk :reset :position-list (list prev-av (v+ prev-av scale-av)) :time-list (list tm)) (send minjerk :start-interpolation) (send minjerk :pass-time (/ tm div)) (dotimes (i div) (setq avs (append avs (list (send minjerk :pass-time (/ tm div)))))) (send* self :angle-vector-sequence-raw avs (make-list div :initial-element (/ tm div)) args) (return-from :angle-vector-raw (car (last avs))))) (send-super* :angle-vector av tm args))
  12: at (apply #'send self :angle-vector-raw av tm ctype start-time args)
  13: at (apply #'send self :angle-vector-raw av tm ctype start-time args)
  14: at (send* self :angle-vector-raw av tm ctype start-time args)
  15: at (return-from :angle-vector (send* self :angle-vector-raw av tm ctype start-time args))
  16: at (progn (return-from :angle-vector (send* self :angle-vector-raw av tm ctype start-time args)))
  17: at (if (send self :simulation-modep) (progn (return-from :angle-vector (send* self :angle-vector-raw av tm ctype start-time args))))
  18: at (when (send self :simulation-modep) (return-from :angle-vector (send* self :angle-vector-raw av tm ctype start-time args)))
  19: at (let ((ctype controller-type) (start-time 0) (start-offset-time nil) (use-torso t) (clear-velocities t)) (if (= (length args) 1) (setq ctype (car args) args (cdr args))) (if (and (>= (length args) 2) (null (member (car args) '(:use-torso :start-time :clear-velocities)))) (setq ctype (car args) start-time (cadr args) args (cddr args))) (if (member :use-torso args) (setq use-torso (cadr (member :use-torso args)))) (if (member :start-time args) (setq start-time (cadr (member :start-time args)))) (if (member :start-offset-time args) (setq start-offset-time (cadr (member :start-offset-time args)))) (if (member :clear-velocities args) (setq clear-velocities (cadr (member :clear-velocities args)))) (when (send self :simulation-modep) (return-from :angle-vector (send* self :angle-vector-raw av tm ctype start-time args))) (when (not (numberp tm)) (warn ":angle-vector tm is not a number, use :angle-vector av tm args")) (send* self :angle-vector-motion-plan av :ctype ctype :move-arm :rarm :total-time tm :start-offset-time (if start-offset-time start-offset-time start-time) :clear-velocities clear-velocities :use-torso use-torso args))
  And more...
/opt/ros/melodic/share/euslisp/jskeus/eus/Linux64/bin/irteusgl 0 error: no such keyword :use-torso in (apply #'send-message self (class . super) :angle-vector-sequence args)
