(defclass link-pair
  :super propertied-object
  :slots (from to))

(defmethod link-pair
  (:init (from-obj to-obj)
    (setq from from-obj)
    (setq to to-obj)
    self)
  (:worldcoords ()
    (midcoords 0.5 from to))
  (:vertices ()
    (append (send from :vertices) (send to :vertices)))
  (:from () from)
  (:to () to)
  (:include (link-list)
    (dolist (l link-list)
      (if (or (eq l from)
              (eq l to))
          (return-from :include t)))
    nil)
  (:to-list (link-list)
    (if (member from link-list)
        (list from to)
      (list to from)))
  (:is-same-pair (p)
    (or (and (eq (send p :from) from) (eq (send p :to) to))
        (and (eq (send p :to) from) (eq (send p :from) to))))
  (:joints-between ()
    (let ((link-route1 (send robot :find-link-route from to))
          (link-route2 (send robot :find-link-route to from)))
      (unique (send-all (append link-route1 link-route2) :joint))))
  (:joints-same ()
    (let ((js (send self :joints-between)))
      
      ))
  (:link-distance ()
    (car (pqp-collision-distance from to)))
  (:is-valid-link-pair (robot)
    ;; 1. links connected one joint should be ignored
    (cond ((or (eq (send from :parent) to)
               (eq (send to :parent) from))
           nil)
          
          (t
           ;; two links belongs to the same limb, ignore it
           (let ((larm-links (send robot :larm :links))
                 (rarm-links (send robot :rarm :links))
                 (lleg-links (send robot :lleg :links))
                 (rleg-links (send robot :rleg :links))
                 (head-links (send robot :head :links))
                 (torso-links (cons (send robot :link "BODY") (send robot :torso :links))))
             (not (or (and (member from larm-links)
                           (member to larm-links))
                      (and (member from rarm-links)
                           (member to rarm-links))
                      (and (member from lleg-links)
                           (member to lleg-links))
                      (and (member from rleg-links)
                           (member to rleg-links))
                      (and (member from head-links)
                           (member to head-links))
                      (and (member from torso-links)
                           (member to torso-links))))))))
  (:draw (vwer)
    (gl::glPushAttrib gl::GL_ALL_ATTRIB_BITS)
    (gl::glDisable gl::GL_LIGHTING)
    (let ((collision (pqp-collision-distance from to)))
      (let ((distance (car collision))
            (from-point (cadr collision))
            (to-point (caddr collision)))
        ;; change color according to distance
        (let ((c (cond ((< distance 100) ;10cm
                        (gl::glLineWidth 4.0)
                        (gl::find-color :red))
                       ((< distance 200) ;10cm
                        (gl::glLineWidth 4.0)
                        (gl::find-color :yellow))
                       ((< distance 300)
                        (gl::glLineWidth 4.0)
                        (gl::find-color :green))
                       (t
                        (gl::glLineWidth 1.0)
                        (gl::find-color nil)))))
          (gl::glBegin gl::GL_LINE_STRIP)
          (gl::glColor3fv c)
          (gl::glVertex3fv from-point)
          (gl::glColor3fv c)
          (gl::glVertex3fv to-point)
          (gl::glEnd)
          )
        ))
    (gl::glEnable gl::GL_LIGHTING)
    (gl::glPopAttrib)
    )
  )


(defclass collision-link-parameter
  :super propertied-object
  :slots (robot distance-table))

(defmethod collision-link-parameter
  (:init (r)
    (setq robot r))
  (:link-volume (l)
    (reduce #'+ (mapcar #'abs (send-all (send l :bodies) :volume))))
  (:is-valid-link (l &optional (volume-thre 200000))
    (> (send self :link-volume l) volume-thre))
  (:valid-links ()
    (remove-if-not #'(lambda (x)
                       (send self :is-valid-link x))
                   (send robot :links)))
  (:invalid-links ()
    (remove-if #'(lambda (x)
                   (send self :is-valid-link x))
               (send robot :links)))
  (:valid-link-pairs (&key (distance-thre 50))
    (let ((pairs nil)
          (valid-links (send self :valid-links))
          (valid-link-pairs nil))
      (dolist (l1 valid-links)
        (dolist (l2 valid-links)
          (when (not (eq l1 l2))
            (let ((pair (instance link-pair :init l1 l2)))
              (if (and
                   (> (send pair :link-distance) distance-thre)
                   (send pair :is-valid-link-pair robot)
                   (null (remove-if-not #'(lambda (p)
                                            (send p :is-same-pair pair))
                                        valid-link-pairs)))
                  (setq valid-link-pairs (append valid-link-pairs (list pair))))))))
      valid-link-pairs))
  (:init-distance-table (&key (distance-thre 50))
    (let ((link-pairs (send self :valid-link-pairs :distance-thre distance-thre)))
      (setq distance-table (mapcar #'(lambda (p)
                                       (cons p (send p :link-distance)))
                                   link-pairs))))
  (:collision-link-pairs (link-list n)
    (let ((valid-distance-table
           (remove-if-not #'(lambda (d)
                              (let ((pair (car d)))
                                (send pair :include link-list)))
                          distance-table)))
      ;; sort
      (sort valid-distance-table #'(lambda (x y) (< (cdr x) (cdr y))))
      (mapcar #'car (subseq valid-distance-table 0 n))))
  (:collision-avoidance-link-pair (link-list num)
    (send-all (send self :collision-link-pairs link-list num) :to-list link-list))
  )

(defun test-link-pair-visualization ()
  (require "package://hrpsys_ros_bridge_tutorials/euslisp/hrp2jsknt-interface.l")
  (unless (boundp '*robot*)
    (setq *robot* (instance hrp2jsknt-robot :init)))
  (let ((pairs (list (instance link-pair :init
                               (send *robot* :link "BODY")
                               (send *robot* :link "LARM_LINK6"))
                     (instance link-pair :init
                               (send *robot* :link "LARM_LINK2")
                               (send *robot* :link "CHEST_LINK0"))
                     (instance link-pair :init
                               (send *robot* :link "LARM_LINK6")
                               (send *robot* :link "CHEST_LINK0"))
                     (instance link-pair :init
                               (send *robot* :link "BODY")
                               (send *robot* :link "LLEG_LINK3"))
                     (instance link-pair :init
                               (send *robot* :link "LARM_LINK6")
                               (send *robot* :link "LLEG_LINK3"))
                     )))
    (objects (append pairs (list *robot*)))
    ;; test motion
    (do-until-key
     (dotimes (i 100)
       (send *robot* :larm :elbow-p :joint-angle (- i))
       (send *irtviewer* :draw-objects)
       (x::window-main-one)
       )
     (dotimes (i 100)
       (send *robot* :larm :elbow-p :joint-angle (+ (- 100) i))
       (send *irtviewer* :draw-objects)
       (x::window-main-one)
       )
     )
    ))

(defun test-collision-link-parameter-valid-links ()
  (require "package://hrpsys_ros_bridge_tutorials/euslisp/hrp2jsknt-interface.l")
  (unless (boundp '*robot*)
    (setq *robot* (instance hrp2jsknt-robot :init)))
  (let ((pairs (send (instance collision-link-parameter :init *robot*)
                     :valid-link-pairs)))
    (objects (append pairs (list *robot*)))
    ))

(defun test-collision-link-parameter ()
  (require "package://hrpsys_ros_bridge_tutorials/euslisp/hrp2jsknt-interface.l")
  (unless (boundp '*robot*)
    (setq *robot* (instance hrp2jsknt-robot :init)))
  (send *robot* :reset-manip-pose)
  (let ((col (instance collision-link-parameter :init *robot*)))
    (setq *col* col)
    (send col :init-distance-table)
    (let ((ll (send *robot* :link-list (send *robot* :larm :end-coords :parent))))
      (dotimes (i 100)
        (let ((pairs (send col :collision-link-pairs ll i)))
          (send *irtviewer* :objects (cons *robot* pairs))
          (send *irtviewer* :draw-objects)
        )
      )))
  )

;; (load "package://drc_task_common/euslisp/lib/collision-link-parameter.l")