(require :speak "package://pr2eus/speak.l")
;; (jsk)
;; (rbrain)


;;(require "package://drc_task_common/euslisp/robot-util.l")
(setq *log-name* "koyama-carry-trass")

(require "~/prog/euslib/irteus_proposals/motion-lib-proposal.l")

(defun execute-command (&key (command-list (list "y" "n"))
                             (function-list (list #'(lambda () (print "you typed y"))
                                                  #'(lambda () (print "you typed n"))))
                             (message "")
                             (yes nil)
                             )
  (format t "~A~%" message)
  (let ((i 0))
    (if yes 
        (setq cmd "y")
      (setq cmd (read-line)))
    (until (equal cmd (elt command-list i))
           (setq i (1+ i))
           (when (>= i (length command-list)) (setq i nil) (return nil)))
    (when i
      (funcall (elt function-list i))
      cmd
      )
    cmd
    ))

(defclass motion-sequence-server :super propertied-object :slots (rs-list current-index play-flag))
(defmethod motion-sequence-server
  (:init ()
         "initialize the class"
         (setq rs-list nil)
         (setq current-index nil)
         )

  (:stop-play () (setq play-flag nil))
  (:get-rs-index (name)
                 "get the index of motion of command allocated assined to the given name"
                 (position name rs-list :test #'equal :key #'(lambda (x) (send x :name))))
  (:set-current-index (name)
                      "set the current-index to the index of given name"
                      (setq current-index (send self :get-rs-index name)))
  (:set-rs-by-current-index (&key (robot *robot*))
                            (let (rs)
                              (setq rs (elt rs-list current-index))
                              (send rs :set-robot-state robot)
                              rs
                              ))
  (:get-rs-by-current-index (&key (robot *robot*))
                            (elt rs-list current-index))
  (:save-rs (&key (robot *robot*) (command :angle-vector) (time 5000) (name nil) (message nil) (yes nil))
            "save robot state data"
            (let (rsd)
              (setq rsd (instance robot-state-data :init (send robot :angle-vector)
                                  (send (send (send robot :links :body) :worldcoords) :copy-worldcoords) time))
              (send rsd :name name)
              ;;for other than angle-vector
              (send rsd :put :command command)

              ;;save message for play-in-real
              (if message
                  (send rsd :put :message message)
                (format t "do you want to play ~A?~%" (send rsd :name)))
              
              ;;save yes for play-in-real
              (send rsd :put :yes yes)

              ;;save rs to rs-list
              (setq current-index (length rs-list))
              (setq rs-list (reverse rs-list))
              (setq rs-list (reverse (push rsd rs-list)))
              ))
  (:set-rs (&key (robot *robot*) (name nil))
           (let (rs tmp-index)
             (setq tmp-index current-index)
             (if name
                 (send self :set-current-index name))
             (send self :set-rs-by-current-index :robot robot)
             (setq current-index tmp-index)
             (send *irtviewer* :draw-objects)
             ))
  (:get-rs (name)
           (elt rs-list (send self :get-rs-index name)))
  (:set-former-rs (&key(robot *robot*))
                  (when (> current-index 0)
                    (setq current-index (1- current-index))
                    (setq rs (elt rs-list current-index))
                    (format t "set model to ~A~%" (send rs :name))
                    (send self :set-rs :robot robot)
                    ))
  (:set-later-rs (&key(robot *robot*))
                 (when (< current-index (length rs-list))
                   (setq current-index (1+ current-index))
                   (setq rs (elt rs-list current-index))
                   (send self :set-rs :robot robot)
                   ))
  (:play-for-check (&optional (time 500) &key (robot *robot*))
    (let ((i 0) rs)
      (while (< i (length rs-list))
        (setq current-index i)
        (setq rs (send self :set-rs-by-current-index :robot robot))
        (format t "step:~A   ~A~%" current-index (send rs :name))
        (send self :set-rs-by-current-index :robot robot)
        (setq i (1+ i))
        (send *irtviewer* :draw-objects)
        (unix::usleep (* time 1000)))
      ))
  (:model2real (&key (wait? nil) (robot *robot*))
    
    (setq rs (send self :set-rs-by-current-index :robot robot))
    (setq command (send rs :get :command))
    (setq angle-vector (send rs :angle-vector))
    (setq time (send rs :time))
    (format t "execute ~A,time is ~A~%~%~%" (send rs :name) time)
    (speak-en (send rs :name))
    (cond ((eq command :angle-vector)
           (model2real :wait? wait? :time time))
          (t (funcall command))))
  (:play-in-real (&key (robot *robot*) (play-from-first t))
    (let (rs command time angle-vector i)
      (setq play-flag t)
      (when play-from-first (setq current-index 0)
            (send *ri* :start-log))
      (while play-flag 
        (setq rs (send self :set-rs-by-current-index :robot robot))
        (unless (send rs :get :yes)
          (if (send rs :get :message)
              (print (send rs :get :message))
            (format t "do you want to play ~A?~%" (send rs :name))))
        (send *irtviewer* :draw-objects)
        (setq ret (execute-command :command-list (list "y" "r" "s")
                                   :function-list (list #'(lambda () (send self :model2real :robot robot :wait? nil))
                                                        #'(lambda () (send self :set-former-rs :robot robot)
                                                            (setq current-index (1- current-index))
                                                            (send self :model2real :robot robot :wait? nil)
                                                            (send *irtviewer* :draw-objects)
                                                            )
                                                        #'(lambda () (format t "skip ~A~%" (send (send self :set-rs-by-current-index :robot robot) :name)))
                                                        )
                                   :message "select y/r/s"
                                   :yes (send rs :get :yes)
                                   ))
        (when (equal ret "n") (return nil))
                     ;;send command to *ri*
        (setq current-index (1+ current-index))
        (when (not (< current-index (length rs-list))) (setq play-flag nil))
        )
      (print "end of play")
      (speak-en "Experiment is over. Please save log! Please save log!")
      ))
  )
